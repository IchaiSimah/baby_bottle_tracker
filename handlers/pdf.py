import os
import tempfile
from datetime import datetime, timedelta
from io import BytesIO
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch, cm
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak, Image
from reportlab.lib import colors
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfbase.pdfmetrics import stringWidth
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from utils import load_user_stats, load_user_data
from database import get_user_group_id
from zoneinfo import ZoneInfo
import requests
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib import rcParams
import numpy as np
from collections import defaultdict
from translations import t as tr
from database import get_language

LINK_TO_OFFICIAL_INFORMATIONS = "https://www.allobebe.fr/quantite-lait-biberon.html"
# Dictionnaire de traductions pour le PDF
TRANSLATIONS = {
    'fr': {
        'title': 'üìä Rapport de Suivi B√©b√©',
        'group': 'üë• Groupe',
        'period': 'üìÖ P√©riode',
        'generated': 'üìÑ G√©n√©r√© le',
        'general_stats': 'üìä Statistiques G√©n√©rales',
        'metric': 'M√©trique',
        'value': 'Valeur',
        'total_bottles': 'Total biberons',
        'total_ml': 'Total ml consomm√©s',
        'avg_ml_day': 'Moyenne ml/jour',
        'avg_bottles_day': 'Moyenne biberons/jour',
        'diaper_changes': 'Changements de couche',
        'daily_detail': 'üìÖ D√©tail par Jour',
        'bottles': 'Biberons',
        'changes': 'Changements',
        'total': 'Total',
        'complete_bottles': 'üçº Liste Compl√®te des Biberons',
        'date': 'Date',
        'time': 'Heure',
        'quantity_ml': 'Quantit√© (ml)',
        'complete_changes': 'üí© Liste Compl√®te des Changements',
        'information': 'Information',
        'chronological_list': 'üìã Liste Chronologique Compl√®te',
        'type': 'Type',
        'footer_line1': 'üìÑ Rapport g√©n√©r√© automatiquement par Baby Bottle Tracker Bot',
        'footer_line2': 'üìä Donn√©es bas√©es sur',
        'footer_line3': 'jours de suivi',
        'footer_line4': 'üí° Pour plus d\'informations, contactez votre p√©diatre',
        'report_days': 'Rapport',
        'days': 'jours',
        'bottles_count': 'biberons',
        'changes_count': 'changements',
        'generated_on': 'G√©n√©r√© le',
        'daily_consumption_chart': 'Consommation Quotidienne',
        'average': 'Moyenne',
        'maximum': 'Maximum',
        'minimum': 'Minimum',
        'more_info_link': 'Pour plus d\'informations sur les besoins de votre b√©b√©, cliquez ici'
    },
    'en': {
        'title': 'üìä Baby Tracking Report',
        'group': 'üë• Group',
        'period': 'üìÖ Period',
        'generated': 'üìÑ Generated on',
        'general_stats': 'üìä General Statistics',
        'metric': 'Metric',
        'value': 'Value',
        'total_bottles': 'Total bottles',
        'total_ml': 'Total ml consumed',
        'avg_ml_day': 'Average ml/day',
        'avg_bottles_day': 'Average bottles/day',
        'diaper_changes': 'Diaper changes',
        'daily_detail': 'üìÖ Daily Detail',
        'bottles': 'Bottles',
        'changes': 'Changes',
        'total': 'Total',
        'complete_bottles': 'üçº Complete Bottles List',
        'date': 'Date',
        'time': 'Time',
        'quantity_ml': 'Quantity (ml)',
        'complete_changes': 'üí© Complete Changes List',
        'information': 'Information',
        'chronological_list': 'üìã Complete Chronological List',
        'type': 'Type',
        'footer_line1': 'üìÑ Report automatically generated by Baby Bottle Tracker Bot',
        'footer_line2': 'üìä Data based on',
        'footer_line3': 'days of tracking',
        'footer_line4': 'üí° For more information, contact your pediatrician',
        'report_days': 'Report',
        'days': 'days',
        'bottles_count': 'bottles',
        'changes_count': 'changes',
        'generated_on': 'Generated on',
        'daily_consumption_chart': 'Daily Consumption Chart',
        'average': 'Average',
        'maximum': 'Maximum',
        'minimum': 'Minimum',
        'more_info_link': 'For more information on your baby\'s needs, click here'
    },
    'he': {
        'title': 'üìä ◊ì◊ï◊ó ◊û◊¢◊ß◊ë ◊™◊ô◊†◊ï◊ß',
        'group': 'üë• ◊ß◊ë◊ï◊¶◊î',
        'period': 'üìÖ ◊™◊ß◊ï◊§◊î',
        'generated': 'üìÑ ◊†◊ï◊¶◊® ◊ë',
        'general_stats': 'üìä ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™ ◊õ◊ú◊ú◊ô◊ï◊™',
        'metric': '◊û◊ì◊ì',
        'value': '◊¢◊®◊ö',
        'total_bottles': '◊°◊î"◊õ ◊ë◊ß◊ë◊ï◊ß◊ô◊ù',
        'total_ml': '◊°◊î"◊õ ◊û"◊ú ◊©◊†◊¶◊®◊õ◊ï',
        'avg_ml_day': '◊û◊û◊ï◊¶◊¢ ◊û"◊ú ◊ú◊ô◊ï◊ù',
        'avg_bottles_day': '◊û◊û◊ï◊¶◊¢ ◊ë◊ß◊ë◊ï◊ß◊ô◊ù ◊ú◊ô◊ï◊ù',
        'diaper_changes': '◊î◊ó◊ú◊§◊ï◊™ ◊ó◊ô◊™◊ï◊ú',
        'daily_detail': 'üìÖ ◊§◊ô◊®◊ï◊ò ◊ô◊ï◊û◊ô',
        'bottles': '◊ë◊ß◊ë◊ï◊ß◊ô◊ù',
        'changes': '◊î◊ó◊ú◊§◊ï◊™',
        'total': '◊°◊î"◊õ',
        'complete_bottles': 'üçº ◊®◊©◊ô◊û◊™ ◊ë◊ß◊ë◊ï◊ß◊ô◊ù ◊û◊ú◊ê◊î',
        'date': '◊™◊ê◊®◊ô◊ö',
        'time': '◊©◊¢◊î',
        'quantity_ml': ')◊õ◊û◊ï◊™ )◊û"◊ú',
        'complete_changes': 'üí© ◊®◊©◊ô◊û◊™ ◊î◊ó◊ú◊§◊ï◊™ ◊û◊ú◊ê◊î',
        'information': '◊û◊ô◊ì◊¢',
        'chronological_list': 'üìã ◊®◊©◊ô◊û◊î ◊õ◊®◊ï◊†◊ï◊ú◊ï◊í◊ô◊™ ◊û◊ú◊ê◊î',
        'type': '◊°◊ï◊í',
        'footer_line1': 'üìÑ ◊ì◊ï◊ó ◊†◊ï◊¶◊® ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊¢◊ú ◊ô◊ì◊ô ◊ë◊ï◊ò ◊û◊¢◊ß◊ë ◊ë◊ß◊ë◊ï◊ß ◊™◊ô◊†◊ï◊ß',
        'footer_line2': 'üìä ◊†◊™◊ï◊†◊ô◊ù ◊û◊ë◊ï◊°◊°◊ô◊ù ◊¢◊ú',
        'footer_line3': '◊ô◊û◊ô ◊û◊¢◊ß◊ë',
        'footer_line4': 'üí° ◊ú◊û◊ô◊ì◊¢ ◊†◊ï◊°◊£, ◊§◊†◊î ◊ú◊®◊ï◊§◊ê ◊î◊ô◊ú◊ì◊ô◊ù ◊©◊ú◊ö',
        'report_days': '◊ì◊ï◊ó',
        'days': '◊ô◊û◊ô◊ù',
        'bottles_count': '◊ë◊ß◊ë◊ï◊ß◊ô◊ù',
        'changes_count': '◊î◊ó◊ú◊§◊ï◊™',
        'generated_on': '◊†◊ï◊¶◊® ◊ë',
        'daily_consumption_chart': '◊í◊®◊£ ◊û◊ñ◊ï◊û◊ü ◊ô◊ï◊û◊ô',
        'average': '◊û◊û◊ï◊¶◊¢',
        'maximum': '◊û◊ß◊°◊ô◊û◊ï◊ù',
        'minimum': '◊û◊ô◊†◊ô◊û◊ï◊ù',
        'more_info_link': '◊ú◊û◊ô◊ì◊¢ ◊†◊ï◊°◊£, ◊ß◊®◊ê◊ï ◊õ◊ê◊ü'
    }
}

def setup_hebrew_font():
    """Configure la police pour l'h√©breu (NotoSansHebrew locale ou fallback syst√®me)"""
    try:
        # 1. Utiliser la police locale si elle existe
        font_path = os.path.join("assets", "fonts", "NotoSansHebrew-Regular.ttf")
        if os.path.exists(font_path):
            pdfmetrics.registerFont(TTFont('Hebrew', font_path))
            print(f"‚úÖ Police NotoSansHebrew utilis√©e : {font_path}")
            return 'Hebrew'
        # 2. Fallback sur les polices syst√®me Unicode
        system_fonts = [
            'Arial Unicode MS',  # Windows
            'Arial',             # Windows
            'DejaVuSans',        # Linux
            'Liberation Sans',   # Linux
            'Helvetica'          # Mac/Linux
        ]
        for font_name in system_fonts:
            try:
                pdfmetrics.registerFont(TTFont('Hebrew', font_name))
                print(f"‚úÖ Police syst√®me configur√©e : {font_name}")
                return 'Hebrew'
            except Exception as e:
                print(f"‚ùå Impossible d'utiliser {font_name}: {e}")
                continue
        # 3. Fallback ultime
        print("‚ö†Ô∏è Aucune police h√©breu trouv√©e, utilisation de la police par d√©faut")
        return 'Helvetica'
    except Exception as e:
        print(f"‚ùå Erreur configuration police h√©breu : {e}")
        return 'Helvetica'

async def translate_text_with_ai(text: str, target_language: str) -> str:
    """Traduit un texte avec l'IA Gemini (version optimis√©e)"""
    try:
        # V√©rifier si Gemini est disponible
        gemini_api_key = os.getenv("GEMINI_API_KEY")
        if not gemini_api_key:
            print("GEMINI_API_KEY not found, using fallback translation")
            return text
        
        # Try different models in order of preference (higher quota first)
        models_to_try = [
            "gemini-2.5-flash-lite-preview-06-17",  # New model with 1000 requests/day quota
            "gemini-2.5-flash-latest",  # Alternative 2.5 model name
            "gemini-1.5-pro",  # Higher quota than flash
            "gemini-1.5-flash-latest",  # Original model
            "gemini-1.5-flash",  # Alternative flash model
        ]
        
        url_base = "https://generativelanguage.googleapis.com/v1beta/models"
        
        # Cr√©er le prompt de traduction
        language_names = {
            'en': 'English',
            'fr': 'French', 
            'he': 'Hebrew'
        }
        
        prompt = f"""
        Translate the following text to {language_names.get(target_language, target_language)}.
        Keep the translation simple and natural.
        If the text is medical or baby-related, use appropriate terminology.
        
        Text to translate: "{text}"
        
        Only return the translation, nothing else.
        If the text looks gibberish, return the original text.
        """
        
        # Properly format the JSON request
        request_data = {
            "contents": [
                {
                    "parts": [
                        {
                            "text": prompt
                        }
                    ]
                }
            ]
        }
        
        # Try each model until one works
        for model_name in models_to_try:
            try:
                url = f"{url_base}/{model_name}:generateContent"
                params = {"key": gemini_api_key}
                
                response = requests.post(
                    url, 
                    params=params, 
                    json=request_data,
                    headers={"Content-Type": "application/json"},
                    timeout=30
                )
                
                if response.status_code == 200:
                    result = response.json()
                    # Extract the text from the response
                    if 'candidates' in result and len(result['candidates']) > 0:
                        candidate = result['candidates'][0]
                        if 'content' in candidate and 'parts' in candidate['content']:
                            parts = candidate['content']['parts']
                            if len(parts) > 0 and 'text' in parts[0]:
                                ai_text = parts[0]['text'].strip()
                                
                                # Nettoyer le r√©sultat
                                if ai_text.startswith('"') and ai_text.endswith('"'):
                                    ai_text = ai_text[1:-1]
                                
                                return ai_text if ai_text else text
                    
                    print(f"Unexpected response format from {model_name}: {result}")
                    continue
                    
                elif response.status_code == 429:
                    print(f"‚ùå Quota exceeded for model {model_name}, trying next model...")
                    continue
                    
                elif response.status_code == 404:
                    print(f"‚ùå Model {model_name} not found (404)")
                    continue
                    
                elif response.status_code == 400:
                    print(f"‚ùå Bad request for model {model_name} (400)")
                    continue
                    
                else:
                    print(f"‚ùå Error with model {model_name}: {response.status_code}")
                    continue
                    
            except Exception as e:
                print(f"‚ùå Exception with model {model_name}: {e}")
                continue
        
        print("‚ùå All models failed")
        return text
        
    except Exception as e:
        print(f"Erreur traduction IA: {e}")
        return text

async def translate_multiple_texts_with_ai(texts: list, target_language: str) -> list:
    """Traduit plusieurs textes en une seule requ√™te Gemini (optimisation)"""
    try:
        # V√©rifier si Gemini est disponible
        gemini_api_key = os.getenv("GEMINI_API_KEY")
        if not gemini_api_key:
            print("GEMINI_API_KEY not found, using fallback translation")
            return texts
        
        # Filtrer les textes non vides
        non_empty_texts = [text for text in texts if text and text.strip()]
        if not non_empty_texts:
            return texts
        
        # Try different models in order of preference (higher quota first)
        models_to_try = [
            "gemini-2.5-flash-lite-preview-06-17",  # New model with 1000 requests/day quota
            "gemini-2.5-flash-latest",  # Alternative 2.5 model name
            "gemini-1.5-pro",  # Higher quota than flash
            "gemini-1.5-flash-latest",  # Original model
            "gemini-1.5-flash",  # Alternative flash model
        ]
        
        url_base = "https://generativelanguage.googleapis.com/v1beta/models"
        
        # Cr√©er le prompt de traduction multiple
        language_names = {
            'en': 'English',
            'fr': 'French', 
            'he': 'Hebrew'
        }
        
        # Cr√©er une liste num√©rot√©e des textes √† traduire
        texts_list = "\n".join([f"{i+1}. {text}" for i, text in enumerate(non_empty_texts)])
        
        prompt = f"""
        Translate the following {len(non_empty_texts)} texts to {language_names.get(target_language, target_language)}.
        Keep the translations simple and natural.
        If the texts are medical or baby-related, use appropriate terminology.
        
        Texts to translate:
        {texts_list}
        
        Return ONLY the translations in the same order, one per line, numbered 1, 2, 3, etc.
        If a text looks gibberish, return the original text for that line.
        Do not add any explanations or extra text.
        """
        
        # Properly format the JSON request
        request_data = {
            "contents": [
                {
                    "parts": [
                        {
                            "text": prompt
                        }
                    ]
                }
            ]
        }
        
        # Try each model until one works
        for model_name in models_to_try:
            try:
                url = f"{url_base}/{model_name}:generateContent"
                params = {"key": gemini_api_key}
                
                response = requests.post(
                    url, 
                    params=params, 
                    json=request_data,
                    headers={"Content-Type": "application/json"},
                    timeout=30
                )
                
                if response.status_code == 200:
                    result = response.json()
                    # Extract the text from the response
                    if 'candidates' in result and len(result['candidates']) > 0:
                        candidate = result['candidates'][0]
                        if 'content' in candidate and 'parts' in candidate['content']:
                            parts = candidate['content']['parts']
                            if len(parts) > 0 and 'text' in parts[0]:
                                ai_response = parts[0]['text'].strip()
                                
                                # Parser les traductions num√©rot√©es
                                translations = []
                                lines = ai_response.split('\n')
                                
                                for line in lines:
                                    line = line.strip()
                                    if line and any(line.startswith(f"{i+1}.") for i in range(len(non_empty_texts))):
                                        # Extraire le texte apr√®s le num√©ro
                                        translation = line.split('.', 1)[1].strip()
                                        translations.append(translation)
                                    elif line and len(translations) < len(non_empty_texts):
                                        # Si pas de num√©ro, prendre la ligne comme traduction
                                        translations.append(line)
                                
                                # S'assurer qu'on a le bon nombre de traductions
                                while len(translations) < len(non_empty_texts):
                                    translations.append("")
                                
                                # Remplacer les textes originaux par les traductions
                                result_texts = texts.copy()
                                translation_index = 0
                                for i, original_text in enumerate(texts):
                                    if original_text and original_text.strip():
                                        if translation_index < len(translations):
                                            result_texts[i] = translations[translation_index]
                                            translation_index += 1
                                
                                return result_texts
                    
                    print(f"Unexpected response format from {model_name}: {result}")
                    continue
                    
                elif response.status_code == 429:
                    print(f"‚ùå Quota exceeded for model {model_name}, trying next model...")
                    continue
                    
                elif response.status_code == 404:
                    print(f"‚ùå Model {model_name} not found (404)")
                    continue
                    
                elif response.status_code == 400:
                    print(f"‚ùå Bad request for model {model_name} (400)")
                    continue
                    
                else:
                    print(f"‚ùå Error with model {model_name}: {response.status_code}")
                    continue
                    
            except Exception as e:
                print(f"‚ùå Exception with model {model_name}: {e}")
                continue
        
        print("‚ùå All models failed")
        return texts
        
    except Exception as e:
        print(f"Erreur traduction IA multiple: {e}")
        return texts

async def show_pdf_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Affiche le menu de t√©l√©chargement PDF avec s√©lection de langue"""
    query = update.callback_query
    await query.answer()
    language = get_language(query.from_user.id)
    message = tr("pdf_menu", language) + "\n\n"

    
    keyboard = [
        [InlineKeyboardButton(tr("pdf_menu_7_days", language), callback_data="pdf_7_days")],
        [InlineKeyboardButton(tr("pdf_menu_30_days", language), callback_data="pdf_30_days")],
        [InlineKeyboardButton(tr("btn_home", language), callback_data="refresh")]
    ]
    
    await query.edit_message_text(
        text=message,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )

async def show_language_selection(update: Update, context: ContextTypes.DEFAULT_TYPE, days: int):
    """Affiche la s√©lection de langue pour le PDF"""
    query = update.callback_query
    await query.answer()
    language = get_language(query.from_user.id)
    # Stocker les jours dans le contexte
    context.user_data['pdf_days'] = days
    
    message = tr("pdf_lang_selection", language) + "\n\n"
    
    keyboard = [
        [InlineKeyboardButton(tr("pdf_lang_fr", language), callback_data=f"pdf_lang_fr_{days}")],
        [InlineKeyboardButton(tr("pdf_lang_en", language), callback_data=f"pdf_lang_en_{days}")],
        [InlineKeyboardButton(tr("pdf_lang_he", language), callback_data=f"pdf_lang_he_{days}")],
        [InlineKeyboardButton(tr("btn_cancel", language), callback_data="pdf_menu")]
    ]
    
    await query.edit_message_text(
        text=message,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )

async def generate_pdf_report(update: Update, context: ContextTypes.DEFAULT_TYPE, days: int = 7, language: str = 'fr'):
    """G√©n√®re et envoie le rapport PDF dans la langue s√©lectionn√©e"""
    query = update.callback_query
    
    # V√©rifier que nous avons un callback query valide
    if not query:
        print("Erreur: Pas de callback query pour la g√©n√©ration PDF")
        return
    
    await query.answer()
    
    user = update.effective_user
    if not user:
        print("Erreur: Pas d'utilisateur pour la g√©n√©ration PDF")
        return
    
    user_id = user.id
    language = get_language(user_id)
    # Message de chargement
    loading_message = tr("pdf_loading", language)
    
    keyboard = [[InlineKeyboardButton(tr("btn_cancel", language), callback_data="pdf_cancel")]]
    
    await query.edit_message_text(
        text=loading_message,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    
    try:
        # Charger les donn√©es
        stats_data = load_user_stats(user_id, days)
        if not stats_data:
            error_msg = tr("error_loading_data", language)
            await query.edit_message_text(
                text=error_msg,
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton(tr("btn_home", language), callback_data="refresh")
                ]]),
                parse_mode="Markdown"
            )
            return
        
        # Charger les donn√©es du groupe pour le nom
        group_data = load_user_data(user_id)
        group_name = "Mon B√©b√©"
        group_id = None
        timediff = 0
        if group_data:
            group_id = list(group_data.keys())[0]
            group_name = group_data[group_id].get('name', 'Mon B√©b√©')
            timediff = group_data[group_id].get('time_difference', 0)
        # Traduire les notes des cacas si n√©cessaire (optimisation : une seule requ√™te pour toutes les notes)
        if language != 'fr':
            poop_entries = stats_data.get('poop', [])
            if poop_entries:
                # Extraire toutes les notes non vides
                notes_to_translate = []
                note_indices = []
                
                for i, poop_entry in enumerate(poop_entries):
                    if poop_entry.get('info') and poop_entry['info'].strip():
                        notes_to_translate.append(poop_entry['info'])
                        note_indices.append(i)
                
                # Traduire toutes les notes en une seule requ√™te
                if notes_to_translate:
                    print(f"üåç Traduction de {len(notes_to_translate)} notes en {language}...")
                    translated_notes = await translate_multiple_texts_with_ai(notes_to_translate, language)
                    
                    # Appliquer les traductions
                    for i, original_index in enumerate(note_indices):
                        if i < len(translated_notes):
                            poop_entries[original_index]['info'] = translated_notes[i]
        
        # G√©n√©rer le PDF
        pdf_buffer = await create_weekly_pdf(stats_data, group_name, days, language, timediff)
        
        # Envoyer le PDF
        filename = f"rapport_bebe_{language}_{(datetime.now(ZoneInfo('UTC')) + timedelta(hours=timediff)).strftime('%Y%m%d_%H%M')}.pdf"
        
        if not query.message:
            print("Erreur: Pas de message pour envoyer le PDF")
            return
        
        await context.bot.send_document(
            chat_id=query.message.chat.id,
            document=pdf_buffer,
            filename=filename,
            caption=f"üìÑ **{TRANSLATIONS[language]['report_days']} {days} {TRANSLATIONS[language]['days']}** - {group_name}\n\n"
                   f"üìä {len(stats_data.get('entries', []))} {TRANSLATIONS[language]['bottles_count']}\n"
                   f"üí© {len(stats_data.get('poop', []))} {TRANSLATIONS[language]['changes_count']}\n"
                   f"üìÖ {TRANSLATIONS[language]['generated_on']} {(datetime.now(ZoneInfo('UTC')) + timedelta(hours=timediff)).strftime('%d/%m/%Y √† %H:%M')}"
        )
        
        # Supprimer le message actuel
        try:
            await context.bot.delete_message(
                chat_id=query.message.chat.id,
                message_id=query.message.message_id
            )
        except Exception as e:
            print(f"Erreur lors de la suppression du message: {e}")
        
        # Cr√©er un nouveau message principal
        from handlers.queries import get_main_message_content_for_user
        from utils import set_group_message_info, save_data
        
        message_text, keyboard = get_main_message_content_for_user(user_id)
        
        # Envoyer le nouveau message principal
        new_message = await context.bot.send_message(
            chat_id=query.message.chat.id,
            text=message_text,
            reply_markup=keyboard,
            parse_mode="Markdown"
        )
        
        # Mettre √† jour les informations du message dans la base de donn√©es
        if group_id:
            set_group_message_info(group_data, group_id, user_id, new_message.message_id, new_message.chat.id)
            await save_data(group_data, context)
        
    except Exception as e:
        print(f"Erreur lors de la g√©n√©ration PDF: {e}")
        error_msg = "‚ùå Erreur lors de la g√©n√©ration du PDF. Veuillez r√©essayer."
        await query.edit_message_text(
            text=error_msg,
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üè† Accueil", callback_data="refresh")
            ]]),
            parse_mode="Markdown"
        )

async def create_weekly_pdf(stats_data, group_name, days, language='fr', timediff=0):
    """Cr√©e le PDF avec les donn√©es de la semaine dans la langue s√©lectionn√©e"""
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4)
    
    # Obtenir les traductions
    t = TRANSLATIONS.get(language, TRANSLATIONS['fr'])
    
    # Appliquer l'inversion des caract√®res pour l'h√©breu
    if language == 'he':
        t = {key: reverse_hebrew_text(value) for key, value in t.items()}
    
    # Configurer la police pour l'h√©breu si n√©cessaire
    if language == 'he':
        hebrew_font = setup_hebrew_font()
    else:
        hebrew_font = 'Helvetica'
    
    # Styles
    styles = getSampleStyleSheet()
    
    # D√©terminer l'alignement selon la langue
    if language == 'he':
        text_alignment = TA_RIGHT
        table_alignment = 'RIGHT'
    else:
        text_alignment = TA_LEFT
        table_alignment = 'LEFT'
    
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=TA_CENTER,
        textColor=colors.HexColor('#2E86AB'),
        fontName=hebrew_font
    )
    
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=16,
        spaceAfter=20,
        textColor=colors.HexColor('#A23B72'),
        fontName=hebrew_font,
        alignment=text_alignment
    )
    
    normal_style = ParagraphStyle(
        'CustomNormal',
        parent=styles['Normal'],
        fontSize=11,
        spaceAfter=12,
        fontName=hebrew_font,
        alignment=text_alignment
    )
    
    # Contenu du PDF
    story = []
    
    # En-t√™te
    if language == 'he':
        story.append(Paragraph(f"{t['title']}", title_style))
        story.append(Paragraph(f"{group_name} :{t['group']}", subtitle_style))
        story.append(Paragraph(f"{t['days']} {days} :{t['period']}", normal_style))
        story.append(Paragraph(f"{(datetime.now(ZoneInfo('UTC')) + timedelta(hours=timediff)).strftime('%H:%M  %d/%m/%Y')} :{t['generated']}", normal_style))
    else:
        story.append(Paragraph(t['title'], title_style))
        story.append(Paragraph(f"{t['group']}: {group_name}", subtitle_style))
        story.append(Paragraph(f"{t['period']}: {days} {t['days']}", normal_style))
        story.append(Paragraph(f"{t['generated']} {(datetime.now(ZoneInfo('UTC')) + timedelta(hours=timediff)).strftime('%d/%m/%Y √† %H:%M')}", normal_style))
    story.append(Spacer(1, 30))
    
    # Statistiques g√©n√©rales
    entries = stats_data.get('entries', [])
    poop = stats_data.get('poop', [])
    
    total_ml = sum(e['amount'] for e in entries)
    avg_ml_per_day = total_ml / days if days > 0 else 0
    avg_bottles_per_day = len(entries) / days if days > 0 else 0
    
    story.append(Paragraph(t['general_stats'], subtitle_style))
    if language == 'he':
        stats_data_table = [
            [t['value'], t['metric']],
            [f"{len(entries)}", t['total_bottles']],
            [f"{avg_ml_per_day:.0f}ml", t['avg_ml_day']],
            [f"{avg_bottles_per_day:.1f}", t['avg_bottles_day']],
            [f"{len(poop)}", t['diaper_changes']]
        ]
        stats_table = Table(stats_data_table, colWidths=[2*inch, 3*inch])
    else:
        stats_data_table = [
        [t['metric'], t['value']],
        [t['total_bottles'], f"{len(entries)}"],
        [t['avg_ml_day'], f"{avg_ml_per_day:.0f}ml"],
        [t['avg_bottles_day'], f"{avg_bottles_per_day:.1f}"],
        [t['diaper_changes'], f"{len(poop)}"]
        ]
        stats_table = Table(stats_data_table, colWidths=[3*inch, 2*inch])
    stats_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2E86AB')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), hebrew_font),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#F8F9FA')),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
        ('FONTNAME', (0, 1), (-1, -1), hebrew_font),
        ('ALIGN', (0, 1), (-1, -1), table_alignment),
    ]))
    
    story.append(stats_table)
    story.append(Spacer(1, 18))
    
    # Graphique de consommation quotidienne
    if entries:  # Seulement si il y a des donn√©es de biberons
        try:
            # Cr√©er le graphique
            chart_buffer = create_daily_consumption_chart(stats_data, days, language)
            
            if chart_buffer.getvalue():  # V√©rifier que le graphique a √©t√© cr√©√©
                # Ajouter le titre du graphique
                story.append(Paragraph(t.get('daily_consumption_chart', 'Consommation Quotidienne'), subtitle_style))
                story.append(Spacer(1, 8))
                
                # Ajouter le graphique au PDF
                chart_image = Image(chart_buffer, width=6*inch, height=3.6*inch)
                chart_image.hAlign = 'CENTER'
                story.append(chart_image)
                story.append(Spacer(1, 20))
                
                # Ajouter le lien vers plus d'informations
                link_text = t.get('more_info_link', 'Pour plus d\'informations sur les besoins de votre b√©b√©, cliquez ici')

                
                # Cr√©er un paragraphe avec lien cliquable
                link_style = ParagraphStyle(
                    'LinkStyle',
                    parent=normal_style,
                    textColor=colors.HexColor('#2E86AB'),
                    fontSize=10,
                    alignment=text_alignment
                )
                
                # Utiliser le lien global d√©fini en haut du fichier
                link_paragraph = Paragraph(
                    f'<link href="{LINK_TO_OFFICIAL_INFORMATIONS}">{link_text}</link>',
                    link_style
                )
                story.append(link_paragraph)
                story.append(Spacer(1, 10))  # R√©duire l'espacement de 20 √† 10
        except Exception as e:
            print(f"Erreur lors de l'ajout du graphique au PDF: {e}")
            # Continuer sans le graphique en cas d'erreur
    
    # Liste chronologique mixte
    if entries or poop:
        # Utiliser FrameBreak au lieu de PageBreak pour √©viter les pages vides
        # FrameBreak ne force pas une nouvelle page s'il y a de l'espace disponible
        story.append(Spacer(1, 20))  # Espacement avant la section
        story.append(Paragraph(t['chronological_list'], subtitle_style))
        
        # Combiner et trier toutes les entr√©es par date/heure
        all_entries = []
        
        # Ajouter les biberons
        for entry in entries:
            all_entries.append({
                'type': 'bottle',
                'time': entry['time'],
                'data': entry
            })
        
        # Ajouter les changements
        for poop_entry in poop:
            all_entries.append({
                'type': 'poop',
                'time': poop_entry['time'],
                'data': poop_entry
            })
        
        # Trier par date/heure (plus r√©cent en premier)
        all_entries.sort(key=lambda x: x['time'], reverse=True)
        
        # Cr√©er le tableau chronologique
        if language == 'he':
            # Pour l'h√©breu, inverser l'ordre des colonnes (RTL)
            chronological_table_data = [[t['information'], t['type'], t['time'], t['date']]]
            entry_types = []  # Track entry types for color coding
            
            for entry in all_entries:
                date_str = entry['time'].strftime('%d/%m/%Y')
                time_str = entry['time'].strftime('%H:%M')
                
                if entry['type'] == 'bottle':
                    entry_type = f"{t['bottles']}"
                    info = f"{entry['data']['amount']}ml"
                else:
                    entry_type = f"{t['changes']}"
                    info = entry['data'].get('info', '-')
                    if language == 'he' and info != '-':
                        info = reverse_hebrew_text(info)
                
                chronological_table_data.append([info, entry_type, time_str, date_str])
                entry_types.append(entry['type'])  # Track the type
            
            # Largeurs des colonnes invers√©es pour l'h√©breu
            col_widths = [1.8*inch, 1.2*inch, 0.8*inch, 1.2*inch]
        else:
            # Ordre normal pour les autres langues
            chronological_table_data = [[t['date'], t['time'], t['type'], t['information']]]
            entry_types = []  # Track entry types for color coding
            
            for entry in all_entries:
                date_str = entry['time'].strftime('%d/%m/%Y')
                time_str = entry['time'].strftime('%H:%M')
                
                if entry['type'] == 'bottle':
                    entry_type = f"{t['bottles']}"
                    info = f"{entry['data']['amount']}ml"
                else:
                    entry_type = f"{t['changes']}"
                    info = entry['data'].get('info', '-')
                    if language == 'he' and info != '-':
                        info = reverse_hebrew_text(info)
                
                chronological_table_data.append([date_str, time_str, entry_type, info])
                entry_types.append(entry['type'])  # Track the type
            
            # Largeurs des colonnes normales
            col_widths = [1.2*inch, 0.8*inch, 1.2*inch, 1.8*inch]
        
        chronological_table = Table(chronological_table_data, colWidths=col_widths)
        
        # Style du tableau avec couleurs diff√©rentes
        table_style = [
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2E86AB')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), hebrew_font),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('FONTSIZE', (0, 1), (-1, -1), 9),
            ('FONTNAME', (0, 1), (-1, -1), hebrew_font),
            ('ALIGN', (0, 1), (-1, -1), table_alignment),
        ]
        
        # Ajouter des couleurs diff√©rentes pour les lignes
        for i, entry_type in enumerate(entry_types):
            if entry_type == 'bottle':  # Biberon
                table_style.append(('BACKGROUND', (0, i+1), (-1, i+1), colors.HexColor('#E8F4FD')))
            else:  # Changement
                table_style.append(('BACKGROUND', (0, i+1), (-1, i+1), colors.HexColor('#FFF3E0')))
        
        chronological_table.setStyle(TableStyle(table_style))
        story.append(chronological_table)
    
    # Pied de page
    story.append(Spacer(1, 30))
    if language == 'he':
        story.append(Paragraph(
            f"{t['footer_line1']}<br/>"
            f"{t['footer_line2']} {days} {t['footer_line3']}<br/>"
            f"{t['footer_line4']}",
            ParagraphStyle(
                'Footer',
                parent=styles['Normal'],
                fontSize=9,
                textColor=colors.grey,
                alignment=TA_RIGHT,
                fontName=hebrew_font
            )
        ))
    else:
        story.append(Paragraph(
            f"{t['footer_line1']}<br/>"
            f"{t['footer_line2']} {days} {t['footer_line3']}<br/>"
            f"{t['footer_line4']}",
            ParagraphStyle(
                'Footer',
                parent=styles['Normal'],
                fontSize=9,
                textColor=colors.grey,
                alignment=TA_CENTER,
                fontName=hebrew_font
            )
        ))
    
    # G√©n√©rer le PDF
    doc.build(story)
    buffer.seek(0)
    return buffer

async def handle_pdf_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """G√®re les callbacks du menu PDF"""
    query = update.callback_query
    action = query.data
    
    if action == "pdf_7_days":
        await show_language_selection(update, context, 7)
    elif action == "pdf_30_days":
        await show_language_selection(update, context, 30)
    elif action == "pdf_cancel":
        await query.edit_message_text(
            text="‚ùå G√©n√©ration annul√©e",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üè† Accueil", callback_data="refresh")
            ]]),
            parse_mode="Markdown"
        )
    elif action.startswith("pdf_lang_"):
        # Extraire la langue et les jours
        parts = action.split("_")
        if len(parts) >= 4:
            language = parts[2]  # fr, en, he
            days = int(parts[3])  # 7, 30, etc.
            await generate_pdf_report(update, context, days, language)

def reverse_hebrew_text(text: str) -> str:
    """Inverse l'ordre des caract√®res et des mots pour le texte h√©breu"""
    if not text:
        return text
    
    # S√©parer les mots
    words = text.split()
    processed_words = []
    
    for word in words:
        # V√©rifier si le mot contient des caract√®res h√©breu
        if any('\u0590' <= char <= '\u05FF' for char in word):
            # Inverser l'ordre des caract√®res pour les mots h√©breu
            reversed_word = word[::-1]
            processed_words.append(reversed_word)
        else:
            # Garder l'ordre normal pour les mots non-h√©breu (emojis, etc.)
            processed_words.append(word)
    
    # Inverser l'ordre des mots pour l'h√©breu
    processed_words.reverse()
    
    return ' '.join(processed_words)

def create_daily_consumption_chart(stats_data, days: int, language: str = 'fr') -> BytesIO:
    """Cr√©e un graphique de consommation quotidienne"""
    try:
        # Configurer matplotlib pour un rendu non-interactif
        plt.switch_backend('Agg')
        
        # Configuration robuste des polices - √©viter Helvetica sur Windows
        try:
            # Utiliser des polices disponibles sur tous les syst√®mes
            if language == 'he':
                # Pour l'h√©breu, priorit√© √† Noto Sans Hebrew
                font_path = os.path.join("assets", "fonts", "NotoSansHebrew-Regular.ttf")
                if os.path.exists(font_path):
                    rcParams['font.family'] = 'sans-serif'
                    rcParams['font.sans-serif'] = ['Noto Sans Hebrew', 'DejaVu Sans', 'Arial Unicode MS', 'Arial']
                else:
                    # Fallback sur les polices syst√®me Unicode
                    rcParams['font.family'] = 'sans-serif'
                    rcParams['font.sans-serif'] = ['Arial Unicode MS', 'Arial', 'DejaVu Sans', 'Liberation Sans']
            else:
                # Pour les autres langues, utiliser des polices universelles
                rcParams['font.family'] = 'sans-serif'
                rcParams['font.sans-serif'] = ['DejaVu Sans', 'Arial', 'Liberation Sans', 'Tahoma']
            
            rcParams['axes.unicode_minus'] = False  # √âviter les probl√®mes avec les tirets
        except Exception as e:
            print(f"‚ö†Ô∏è Configuration police matplotlib: {e}")
            # Fallback sur la configuration par d√©faut
            pass
        
        # Obtenir les traductions
        t = TRANSLATIONS.get(language, TRANSLATIONS['fr'])
        
        # Pr√©parer les donn√©es
        entries = stats_data.get('entries', [])
        
        # Grouper par jour
        daily_consumption = defaultdict(int)
        for entry in entries:
            # Normaliser la date √† UTC pour √©viter les probl√®mes de timezone
            entry_time = entry['time']
            if entry_time.tzinfo is None:
                # Si pas de timezone, supposer UTC
                entry_time = entry_time.replace(tzinfo=ZoneInfo('UTC'))
            else:
                # Convertir √† UTC
                entry_time = entry_time.astimezone(ZoneInfo('UTC'))
            
            date_key = entry_time.strftime('%Y-%m-%d')
            daily_consumption[date_key] += entry['amount']
        
        # Cr√©er la liste des dates pour la p√©riode
        end_date = datetime.now(ZoneInfo('UTC'))
        start_date = end_date - timedelta(days=days-1)
        
        dates = []
        values = []
        
        current_date = start_date
        while current_date <= end_date:
            date_key = current_date.strftime('%Y-%m-%d')
            dates.append(current_date)
            values.append(daily_consumption.get(date_key, 0))
            current_date += timedelta(days=1)
        
        # Cr√©er le graphique
        fig, ax = plt.subplots(figsize=(10, 6))
        
        # Couleurs du th√®me
        primary_color = '#2E86AB'
        secondary_color = '#A23B72'
        background_color = '#F8F9FA'
        
        # Style du graphique
        ax.set_facecolor(background_color)
        fig.patch.set_facecolor('white')
        
        # Tracer la courbe
        ax.plot(dates, values, color=primary_color, linewidth=3, marker='o', 
                markersize=6, markerfacecolor=primary_color, markeredgecolor='white', 
                markeredgewidth=2)
        
        # Remplir sous la courbe
        ax.fill_between(dates, values, alpha=0.3, color=primary_color)
        
        # Ajouter les valeurs sur les points
        for i, (date, value) in enumerate(zip(dates, values)):
            if value > 0:  # Afficher seulement si il y a eu consommation
                ax.annotate(f'{value}ml', 
                           xy=(date, value), 
                           xytext=(0, 10),
                           textcoords='offset points',
                           ha='center', va='bottom',
                           fontsize=9, fontweight='bold',
                           color=primary_color,
                           bbox=dict(boxstyle='round,pad=0.3', 
                                   facecolor='white', 
                                   edgecolor=primary_color, 
                                   alpha=0.8))
        
        # Configuration des axes
        if language == 'he':
            ax.set_xlabel(reverse_hebrew_text(t.get('date', '◊™◊ê◊®◊ô◊ö')), fontsize=12, fontweight='bold', color=secondary_color)
            ax.set_ylabel(reverse_hebrew_text(t.get('quantity_ml', '◊õ◊û◊ï◊™ (◊û"◊ú)')), fontsize=12, fontweight='bold', color=secondary_color)
        else:
            ax.set_xlabel(t.get('date', 'Date'), fontsize=12, fontweight='bold', color=secondary_color)
            ax.set_ylabel(t.get('quantity_ml', 'Quantit√© (ml)'), fontsize=12, fontweight='bold', color=secondary_color)
        
        # Titre du graphique
        if language == 'he':
            title_text = f" {reverse_hebrew_text(t.get('days', 'jours'))} {days} - {reverse_hebrew_text(t.get('daily_consumption_chart', 'Consommation Quotidienne'))} "
        else:
            title_text = f"{t.get('daily_consumption_chart', 'Consommation Quotidienne')} - {days} {t.get('days', 'jours')}"
        ax.set_title(title_text, fontsize=14, fontweight='bold', color=primary_color, pad=20)
        
        # Format des dates sur l'axe X
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%d/%m'))
        ax.xaxis.set_major_locator(mdates.DayLocator(interval=max(1, days//7)))
        
        # Rotation des labels de dates
        plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')
        
        # Grille
        ax.grid(True, alpha=0.3, linestyle='--', color=secondary_color)
        
        # Limites des axes
        ax.set_ylim(bottom=0)
        if values:
            max_value = max(values)
            ax.set_ylim(top=max_value * 1.2)  # 20% d'espace au-dessus
        
        # Statistiques sur le graphique
        if values:
            avg_consumption = sum(values) / len([v for v in values if v > 0]) if any(v > 0 for v in values) else 0
            max_consumption = max(values)
            min_consumption = min([v for v in values if v > 0]) if any(v > 0 for v in values) else 0
            
            if language == 'he':
                stats_text = f" {avg_consumption:.0f}ml : {reverse_hebrew_text(t.get('average', 'Moyenne'))}\n"
                stats_text += f" {max_consumption}ml : {reverse_hebrew_text(t.get('maximum', 'Maximum'))}\n"
                if min_consumption > 0:
                    stats_text += f" {min_consumption}ml : {reverse_hebrew_text(t.get('minimum', 'Minimum'))}"
            else:
                stats_text = f" {t.get('average', 'Moyenne')}: {avg_consumption:.0f}ml\n"
                stats_text += f" {t.get('maximum', 'Maximum')}: {max_consumption}ml\n"
                if min_consumption > 0:
                    stats_text += f" {t.get('minimum', 'Minimum')}: {min_consumption}ml"
            
            # Positionner les stats en haut √† droite
            ax.text(0.98, 0.98, stats_text,
                   transform=ax.transAxes,
                   fontsize=10,
                   verticalalignment='top',
                   horizontalalignment='right',
                   bbox=dict(boxstyle='round,pad=0.5',
                           facecolor='white',
                           edgecolor=primary_color,
                           alpha=0.9),
                   fontfamily='sans-serif',
                   fontproperties=None)
        
        # Ajuster la mise en page
        plt.tight_layout()
        
        # Sauvegarder en m√©moire
        buffer = BytesIO()
        plt.savefig(buffer, format='png', dpi=300, bbox_inches='tight', 
                   facecolor='white', edgecolor='none')
        buffer.seek(0)
        plt.close()
        
        return buffer
        
    except Exception as e:
        print(f"Erreur lors de la cr√©ation du graphique: {e}")
        # Retourner un buffer vide en cas d'erreur
        return BytesIO() 